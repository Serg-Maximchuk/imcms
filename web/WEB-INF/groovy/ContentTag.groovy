import com.imcode.imcms.servlet.tags.TextTagimport imcode.server.Imcmsimport imcode.server.parser.ParserParametersimport groovy.sql.Sqldef withSql(closure) {    def dataSource = Imcms.apiDataSource    def connection = dataSource.connection        try {    	sql = new Sql(connection)    	    	closure.call(sql)    } finally {    	connection.close()    }}def getLoopCount(metaId, contentNo) {    def count;        def q = """       select count(l.loop_id) count from contents c join content_loops l        on c.content_id = l.content_id       where c.meta_id = ${metaId} and c.content_no = ${contentNo}    """        withSql { sql ->    	sql.eachRow(q) {    		count = it.count    	}            }            return new Integer(count.toString())}def getOrdredLoopIndexes(metaId, contentNo) {    def count;        def q = """       SELECT l.loop_index loop_index       FROM contents c JOIN content_loops l ON c.content_id = l.content_id       WHERE c.meta_id = ${metaId} AND c.content_no = ${contentNo}       ORDER BY order_index    """        def indexes = []        withSql { sql ->        sql.eachRow(q) {        	indexes << (it.loop_index as Integer)        }            }            return indexes}def getContentId(metaId, contentNo) {        def q = """        select content_id, base_index from contents        where meta_id = ${metaId} and content_no = ${contentNo}     """        def contentId = null    def baseIndex = null         withSql { sql ->         sql.eachRow(q) {        	contentId = it.content_id            baseIndex = it.base_index        }    }              if (!contentId) {        baseIndex = contentTag.baseIndex                withSql { sql ->             def keys = sql.executeInsert("insert into contents (content_no, meta_id, base_index) values (?,?,?)", [contentNo, metaId, baseIndex])            contentId = keys[0][0]                        def ins = """                insert into content_loops (content_id, loop_index, order_index)                values (${contentId}, 0, 0)            """                        sql.executeInsert(ins)        }                    }            return contentId}def addFirst(metaId, contentNo) {	def contentId = getContentId(metaId, contentNo)	    def q = """        select max(l.loop_index) loopIndex, min(l.order_index) minOrderIndex from contents c join content_loops l on c.content_id = l.content_id        where c.meta_id = ${metaId} and c.content_no = ${contentNo}    """    def minOrderIndex = 0    def loopIndex = 0        withSql { sql ->          sql.eachRow(q) {        	loopIndex = it.loopIndex        	minOrderIndex = it.minOrderIndex        }    }        def ins = """        insert into content_loops (content_id, loop_index, order_index)        values (${contentId}, ${loopIndex + 1}, ${minOrderIndex - 1})    """          withSql { sql ->         sql.executeInsert(ins)    }      }def addLast(metaId, contentNo) {	def contentId = getContentId(metaId, contentNo)	    def q = """        select max(l.loop_index) loopIndex, max(l.order_index) maxOrderIndex from contents c join content_loops l on c.content_id = l.content_id        where c.meta_id = ${metaId} and c.content_no = ${contentNo}    """    def maxOrderIndex = 0    def loopIndex = 0        withSql { sql ->          sql.eachRow(q) {            loopIndex = it.loopIndex            maxOrderIndex = it.maxOrderIndex        }    }        def ins = """        insert into content_loops (content_id, loop_index, order_index)        values (${contentId}, ${loopIndex + 1}, ${maxOrderIndex + 1})    """          withSql { sql ->         sql.executeInsert(ins)    } }def removeLast(metaId, contentNo) {	def contentId = getContentId(metaId, contentNo)	    def q = """        select count(l.loop_id) count, max(l.order_index) maxOrderIndex from contents c join content_loops l on c.content_id = l.content_id        where c.meta_id = ${metaId} and c.content_no = ${contentNo}    """    def maxOrderIndex = 0    def count = 0        withSql { sql ->          sql.eachRow(q) {        	count = it.count        	maxOrderIndex = it.maxOrderIndex        }    }        if (count > 1) {    	q = "delete from content_loops where content_id = ${contentId} and order_index = ${maxOrderIndex}"    	    	withSql { sql ->     		sql.executeUpdate(q)        }    	    }    }def getGroupData() {    def groupData = contentTag.pageContext.getAttribute("groupData")        groupData?.itemsMap}def getGroup(parserParameters) {    def groupData = getGroupData()            // start tag case    if (!groupData) return null        // empty group    def size = groupData.size()    if (size == 0) return null        def items = groupData.get(0)            println ">>> id" + document.id        items.each {        println ">>>" + it.class        println ">>>" + it.attributes.no                if (it instanceof com.imcode.imcms.servlet.tags.TextTag) {                    }    }        document.getText }def request = contentTag.pageContext.requestdef response = contentTag.pageContext.responsedef parserParameters = ParserParameters.fromRequest(request)def documentRequest = parserParameters.documentRequestdef document = documentRequest.document// Creates new content and content loop if ones do not existgetContentId(document.id, contentTag.no);if (parserParameters.groupMode) {	def cmd = request.getParameter("cmd")		switch (cmd) {	    case "addFirst":	        addFirst(document.id, contentTag.no)	        break	    	    case "addLast":	        addLast(document.id, contentTag.no)	        break	        	    case "removeLast":	        removeLast(document.id, contentTag.no)	        break   	        	    case "remove":	        remove(document.id, contentTag.no)	        break	        	    case "moveUp":	        remove(document.id, contentTag.no)	        break	        	    case "moveDown":	        remove(document.id, contentTag.no)	        break         	        	}}//bindingsordredLoopIndexes = getOrdredLoopIndexes(document.id, contentTag.no)/*try {    def stmt = connection.createStatement()    def rs = stmt.executeQuery(query)    sout.write csvHeader.toString().bytes        while (rs.next()) {        sout.write rs.getString(1).bytes    }} finally {    connection.close()}*/