import com.imcode.imcms.servlet.tags.TextTagimport imcode.server.Imcmsimport imcode.server.parser.ParserParametersimport groovy.sql.Sqldef withSql(closure) {    def dataSource = Imcms.apiDataSource    def connection = dataSource.connection        try {    	sql = new Sql(connection)    	    	closure.call(sql)    } finally {    	connection.close()    }}def getEntriesCount(metaId, groupNo) {    def count;        def q = """       select count(e.entry_index) count from groups g join group_entries e        on g.group_id = e.group_id       where g.meta_id = ${metaId} and g.group_no = ${groupNo}    """        withSql { sql ->    	sql.eachRow(q) {    		count = it.count    	}            }            count = Math.max(count, 1L)        return new Integer(count.toString())}def addFirst(metaId, groupNo) {    addLast(metaId, groupNo)}def removeLast(metaId, groupNo) {    def q = """        select count(e.entry_index) count, max(e.entry_index) max from groups g join group_entries e on g.group_id = e.group_id        where g.meta_id = ${metaId} and g.group_no = ${groupNo}    """    def count = 0    def entryIndex = 0            withSql { sql ->     	sql.eachRow(q) {    		count = it.count    		entryIndex = it.max    	}    }        if (count > 1) {    	q = "delete from group_entries where group_id = ${groupNo} and entry_index = ${entryIndex}"    	    	withSql { sql ->     		sql.executeUpdate(q)        }    	    }    }def addLast(metaId, groupNo) {    def q = """        select group_id, base_index from groups        where meta_id = ${metaId} and group_no = ${groupNo}     """        def groupId = null    def baseIndex = null         withSql { sql ->     	sql.eachRow(q) {            groupId = it.group_id            baseIndex = it.base_index    	}    }              if (!groupId) {        baseIndex = contentTag.baseIndex                withSql { sql ->         	def keys = sql.executeInsert("insert into groups (group_no, meta_id, base_index) values (?,?,?)", [groupNo, metaId, baseIndex])            groupId = keys[0][0]    	}    }                            q = """        select count(e.entry_index) count, max(e.entry_index) max from groups g join group_entries e on g.group_id = e.group_id        where g.meta_id = ${metaId} and g.group_no = ${groupNo}    """    def count = 0    def entryIndex = 0            withSql { sql ->      	sql.eachRow(q) {    		count = it.count    		entryIndex = it.max    	}    }                if (count == 0) {        entryIndex = 0                def ins = """            insert into group_entries (group_id, entry_index, entry_order_index)            values (${groupId}, 0, 0)        """                withSql { sql ->             sql.executeInsert(ins)        }            }        def ins = """        insert into group_entries (group_id, entry_index, entry_order_index)        values (${groupId}, ${entryIndex + 1}, 0)    """          withSql { sql ->         sql.executeInsert(ins)    } }def getGroupData() {    def groupData = contentTag.pageContext.getAttribute("groupData")        groupData?.itemsMap}def getGroup(parserParameters) {    def groupData = getGroupData()            // start tag case    if (!groupData) return null        // empty group    def size = groupData.size()    if (size == 0) return null        def items = groupData.get(0)            println ">>> id" + document.id        items.each {        println ">>>" + it.class        println ">>>" + it.attributes.no                if (it instanceof com.imcode.imcms.servlet.tags.TextTag) {                    }    }        document.getText }def request = contentTag.pageContext.requestdef response = contentTag.pageContext.responsedef parserParameters = ParserParameters.fromRequest(request)def documentRequest = parserParameters.documentRequestdef document = documentRequest.document// binding// return itemCount for groupitemsCount = getEntriesCount(document.id, contentTag.no)if (!parserParameters.groupMode) returnif (processCmd == null) returndef cmd = request.getParameter("cmd")switch (cmd) {    case "addFirst":        addFirst(document.id, contentTag.no)        break        case "addLast":        addLast(document.id, contentTag.no)        break            case "removeLast":        removeLast(document.id, contentTag.no)        break               case "remove":        remove(document.id, contentTag.no)        break            case "moveUp":        remove(document.id, contentTag.no)        break            case "moveDown":        remove(document.id, contentTag.no)        break                 }/*try {    def stmt = connection.createStatement()    def rs = stmt.executeQuery(query)    sout.write csvHeader.toString().bytes        while (rs.next()) {        sout.write rs.getString(1).bytes    }} finally {    connection.close()}*/